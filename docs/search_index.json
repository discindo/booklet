[["index.html", "Препораки за повторливо анализирање на податоци Абстракт", " Препораки за повторливо анализирање на податоци Теофил Наков, Новица Наков 2020-12-16 Абстракт Волуменот на податоци достапни за најразлични потреби и од најразлични извори расте континуирано. Обработката и објавувето на резултати и податоци, дали од Интернет сообраќајот на вашиот вебсајт, од финансиските трансакции на вашата фирма, од анкети за политички мислења, или од лабораториски експерименти, станува се побрзо и полесно. Исто како и користењето на податоци собрани од Интернет за бизнис одлуки во рамките на вашата фирма. Заедничка за оваа транзиција кон наука за податоци, лична медицина, или бизнис интелегенција, е потребата за транспарентност, отвореност, и повторливост на анализите и резултатите од кои зависиме се повеќе и повеќе. Дали интерно, во нашата фирма за бизнис интелегенција, или јавно за нашите научни истражувања или епидемиолошки предвидувања, доверливи и безбедни процедури за анализа на податоци никогаш не биле толку значајни. Во овој прирачник се осврнуваме токму на овие таканаречени „најдобри“ пракси за безбедно, стабилно, и повторливо работење со податоци. Ќе зборуваме за проблемите што се јавуваат поради не-повторливост, за главните индикатори за не-повторливи проекти, како и за принципите и праксите кои ни овозможуваат да ги надминеме овие проблеми. Низ текстот се обидуваме да дадеме кратки примери, дали вербални или со код, кои ги илустрираат главните препораки и посочуваат кон адекватни софтверски решенија. Се држиме до програмскиот јазик R, којшто е од примарна значајност во светот на анализа на податоци и машинско учеке, има активна заедница посветена токму на проблемот на повторливи анализи, и голем број на алатки (библиотеки) кои го олеснуваат процесот на повторливост при обработка на податоци. Нашата главна препорака е, без разлика на програмскиот јазик кој го користите, или стратегијата за организирање на проекти што најмногу прилега, бидете трпеливи, дисциплинирани, и доследни кон почитувањето на препораките за повторливост. Оваа инвестиција ќе ви се исплати на краток и долг рок во форма на заштедено време и ресурски, унапредување, или соработка. "],["intro.html", "Chapter 1 Вовед 1.1 Аналогија 1.2 За кого е наменет овој прирачник 1.3 Организација 1.4 За овој прирачник", " Chapter 1 Вовед Во овој текст правиме краток преглед и даваме основни препораки за безбедна пракса при ракување, анализирање, и објавување на податоци. Под „безбедна пракса“ подразбираме чекори коишто доколку ги следиме ќе имаме некаква сигурност дека нашата анализа ќе може да биде повторена во друг контекст (друг компјутер, друга организација, после една година, итн) давајќи ги истите резултати. За оваа цел, потребни е да размислуваме за тоа како наједноставно и најбезбедно да ги споделиме нашите податоци, процедури, и програмски код заедно со самите резултати. Инаку, нема никаква надеж дека нашите резултати ќе можат да се повторат. Се чини дека оваа поента е доволно очигледна и некој би рекол дека воопшто нема потреба да се зборува за ова. Сите се согласуваме со тоа дека кога некоја наша колешка ќе направи некаква анализа, ние, доколку имаме доволно информации за нејзината анализа, можеме да ја повториме и да ги добиеме истите резултати. Но во пракса оваа удобна идеја ретко кога се остварува (Minocher et al. 2020). Наместо повторливост, кога се обидуваме да повториме некоја анализа вообичаено е да се соочиме со забуна и фрустрација. Ова често завршува со откажување или правење на анализата од почеток, односно, бесполезно и контрапродуктивно губење на време, ресурси и пари. За брз вовед во овие проблеми и значајноста на повторливоста во истражувањето, ви го препорачуваме ова видео од Ричард МкЕлреат. Горната дефиниција на „безбедна пракса“ (без преправање дека ова е некаква прецизна дефиниција) повикува барем две дополнителни поенти за тоа што подразбира да анализираме податоци и да објавуваме резултати на начин што овозможува точно повторување. Имено, објавувањето на резултат мора да биде поддржано со објавување на 1) точните податоци коишто биле употребени да се направи анализата, и 2) деталната процедура којашто била извршена за да се добие резултатот. Подоцна ќе видиме зошто се неопходни овие компоненти (иако веруваме дека е горе-доле очигледно) и на кој начин е најдобро да се презентираат/објават. Тука е можеби полезно да направиме разлика помеѓу повторливоста која ја опишуваме до сега и еден друг тип на повторливост што има нешто поголема фундаменталност и тежина. Во природните науки, кога зборуваме дека нешто е научна вистина или научно знаење, тоа скоро секогаш се однесува на резултати коишто се повторливи и коишто можат да се докажат од различни агли. Дали почнувајќи со различни податоци, или со поставување на нови експерименти, или со употреба на поинакви анализи, критично е да дојдеме до истиот резултат за тој да биде прифатен како една компонента од тоа како светот функционира (научна вистина). На пример, дека Земјата е сферична може да се докаже со податоци од циркумнавигација, со мерење на аголот на сончевите зраци на различни географски локации, со движењето на Фуковото нишало, со самото постоење на ГПС навигација, со фотографии од возила во орбитата, и така натаму. Значи истиот резултат можеме да го изведеме од многу различни податоци и методи. За разлика од ваквата репликација, фокусот на овој текст е поскромен, и се однесува на далеку полесниот концепт на повторување на истиот рецепт, со истите состојки, за да ја направиме истата пита. 1.1 Аналогија Проширување на горната аналогија е добар начин да се запознаеме со главните компоненти на повторливата обработка на податоци. Кога правиме пита, имаме состојки (брашно, квасец, спанаќ, сирење), рецепт од неколку чекори (нарасни го квасецот, замеси тесто, засукај кори), и неопходни алатки (лонче, тарун, тепсија, фурна). Кога сакаме да ја направиме истата пита што ја прави бабата на нашиот пријател, треба да ги имаме сите состојки, информации за сите чекори за подготовка како и сите алатки. Ако имаме брашно, вода и сол ама сме заборавиле квасец, нема да може да замесиме тесто. Ако немаме сукало, ќе треба да тегнеме кори, што секако ќе значи поинаква пита. Значи, за да ја повториме питата потребно е да ги имаме сите неопходни елементи и инфмормации коишто ќе овозможат точно повторување на секој чекор. Затоа не е чудно што рецепти за готвење често доаѓаат со слики или видео. Тоа се медиуми побогати со информации и затоа поадекватни за пренесување комплексни процеси како правење пита. Без разлика од тоа колку детално некој опишал како се сука кора со радиус од 25 cm, со видео од процесот ние добиваме далеку подобро разбирање за процедурата. Во сферата на анализа за податоци, аналозите на горните компоненти се: податоците ~ состојки изворниот код ~ рецепт и софтверски пакети од коишто зависи нашиот код ~ алатки На пример, ако правиме анализа на невработеност низ Северна Македонија и имаме една табела со невработеност по општини но сме ги групирале податоците по градови користејќи друга табела, тогаш за точна репликација на нашата анализа треба да ги споделиме двете табели (и брашното и квасецот). Слично, за некој да ги направи истите графици за невработеност по град, треба да го споделиме и нашиот код за правење на анализата (рецептот), како и информации за софтверот во којшто сме го извршиле тој програмски код (тарунот). Некогаш тарунот не е неопходен за да се направи истата пита, можеби само температурата на фурната е битна, и во ваквите случаи можеме да го споделиме рецептот без рестрикција за алатката што треба да се користи. Но во други случаи, дури и да се достапни точните податоци и документираниот изворен код, анализата не може да се повтори без некоја специјална алатка. Во овие случаи ние би требало да ги спакуваме и споделиме дури и нашите алатки. За среќа, аналогијата помеѓу правење пита и повторување на некоја анализа завршува со споделување на податоците, кодот, и информации за алатките. Имајќи пристап до овие компоненти, дури и никогаш да не сте правеле некаква специфична анализа во некој специфичен софтвер, вие сепак ќе можете да ги извршите истите документирани чекори и да дојдете до истиот резултат. Повторувањето на анализата не бара пракса, умешност, искуство и не зависи од тоа колку е влажно брашното. Ако креирањето повторливи документи или анализи ви звучеше како комплициран концепт, се надеваме дека со оваа аналогија станува јасно дека е далеку полесно од обидот да се направи пита како како бабата на пријателот или пица како од ресторан. 1.2 За кого е наменет овој прирачник Краткиот одговор е: На секој што работи во сферата на истражување, статистика, наука за податоци, за секој што е студент во овие струки, и за секој што е претпоставен на луѓе кои работат во овие и слични струки. Со други зборови, доколку работите со податоци, и некогаш сте се нашле во ситуација кога некој колега, претпоставен, ментор, соработник, донор, рецензент, едитор, новинар, политичар, итн, ве прашал за тоа како може да се повторат или потврдат вашите резултати, тогаш веројатно има нешто во овој прирачник што би ви било од корист. Да разгледаме некои примери. Пример 1: Работите во невладина организација чијшто фунцкионирање зависи од надворешни грантови, како од македонски така и од странски извори. Се почесто, донорите поставуаат услови за активностите кои тие ги подджуваат, дека сите податоци кои вашата организација ги собира (преку анкети, истражувања, и контакти) како и сите анализи на тие податоци треба да се транспарентни и повторливи. Што во пракса значи дека со завршниот извештај за проектот во кој ги презентирате резултатите, вие ќе треба исто така да покажете јавна депозиција на податоците и изворниот код користен да се добиат презентираните резултати. Со други зборови, пред вас е задача за повторлива анализа Пример 2: Работите во индустриска лабораторија каде што вашата работа е да правите статистичка обработка на експериментални резултати или анализи за контрола на квалитет. Вашата организација повторно фунцкионира преку надворешни грантови или клиенти кои очекуваат дека резултатите од вашата лабораторија ќе може да бида независно потврдени. Во пракса ова повторно значи објавување на повторлив проект, со податоци и програмски код, кој што ќе фунцкионира во контекст многу различен од вашата лабораторија. Пример 3: Накратко, бидејќи патернот е јасен. Вие сте научен истражувач на некој универзитет или институт. Вашата работа зависи од објавување трудови и аплицирање за грантови. Се поголем број на научни журнали имаат стриктни барања за транспарентни и повторливи анализи без кои нема ни да го рецензираат трудот. Вас ви треба повторлив проект. Веројатно е полесно да се зборува за кого овој прирачник не е корисен? Доколку се чувствувате како експерт по сите алатки спомнати во Поглавје 2, тогаш веројатно нема да научите многу од овој текст. Сепак, овој прирачник наменет за почетници или искусни истражувачи но без пракса за повторливи анализи. Но тоа не значи дека не можете да помогнете со пријателска рецензија или со подобрување на некое поглавје каде што чувствувате дека има простор за значајно подобрување. 1.3 Организација Темата на овој текст е доволно опширна што тука нема ни да се обидеме да дадеме севкупен третмант на сите значајни аспекти. Туку, целта е да дадеме преглед на главните принципи за повторливи анализи и практични примери за главните препораки. По воведот, прво ќе се запознаеме со софтверските алатки кои ќе ги користиме понатаму (Поглавје 2: Алатки), и ќе посочиме некои од најчестите случаи кога една анализа, дури и да имаме најдобри намери, може да биде “неповторлива“ (Поглавје 3: Aнализи што не може да се повторат). Понатаму ќе ги разгледаме главните начини на кои постоечки код за некоја анализа која е тешка да се повтори може да се конвертира во повторлива анализа (Поглавје 4: Конверзија во повторлив код). Следи вовед во таканаречено „писмено програмирање“, односно пишување на документи коишто ги покажуваат нашите размислувањз, претпоставки, хипотези, заедно со кодот што го користиме за нивно тестирање и резултатите од тие тестови (Поглавје 5: Повторливи документи / извештаи). Во Поглавје 6 ќе видиме како да организираме еден поголем проект, со неколку различни извори на податоци, скрипти, извештаи и резултати, во еден пакет со документација и стандардна структура што е лесна да се следи и користи. За крај, ќе зборуваме за контола на изворниот код со git што ни дава слобода и безбедност за променување и подобрување (Поглавје 7: Контрола на изворниот код). Текстот го затвораме со заклучок и литература со препорака во најмала рака да ги погледнете ресурсите дадени во библиографијата бидејќи содржат далеку подетални и ефективни третмани на темата на повторливо ракување, анализирање и објавување на податоци. 1.4 За овој прирачник Овој прирачник е изработен како дел од проектот „Отворени податоци за отворена иднина“, поддржан од програмата Цивика Мобилитас, а спроведен од Слободен софтвер Македонија. Содржината на овој прирачник е единствена одговорност на Слободен софтвер Македонија и на ниту еден начин не може да се смета дека ги одразува гледиштата на Цивика мобилитас, Швајцарската агенција за развој и соработка (SDC) или организациите што ја спроведуваат. "],["tools.html", "Chapter 2 Алатки 2.1 Програмски јазик: R 2.2 Контрола на изворен код: git 2.3 Резиме", " Chapter 2 Алатки 2.1 Програмски јазик: R Генерално земено, во денешно време, доколку анализирате податоци тоа веројатно го правите со помош на Python (Rossum 1995) (и пакети како: pandas (McKinney and others 2011), numpy (Harris et al. 2020), matplotlib (Barrett et al. 2005)) или R (R Core Team 2020) (со пакети како: dplyr (Wickham, François, et al. 2020), data.table (Dowle and Srinivasan 2019), ggplot2 (Wickham, Chang, et al. 2020)). Доколку работите на пониско ниво или вашата работа е поблиска до математика, можеби користите c# за побрз код, но генерално, ретко кога јазик од типот на c# сe користи за интерактивна анализа на податоци, графирање, или машинско учење. Понови јазици, и помалку распространети, јазици како Julia и Scala имаат дополнителни предности со тоа што овозможуваат полесно пишување код во истражувачки сесии како Python или R но со брзина на компутација што е поблиска до c или c#. Во секој случај, препораките дадени во овој текст се апликабилни без разлика на програмскиот јазик што го користите. Во овој текст генерално ќе работиме со софтверски алатки од R екосистемот. R е програмски јазик пред се наменет кон статистички анализи, и иако не е најраспространет или најшироко користен, е од особено значење за анализа на податоци, и следствено повторлива анализа на податоци. Главните причини за употребата на R авторите на овој текст секојдневно користат R и Rstudio и поради тоа што има еден куп дополнителни екстензии во оваа средина кои овозможуваат лесно пишување на повторливи технички извештаи, научни трудови (Rmarkdown (Allaire et al. 2020)), книги (bookdown (Xie 2020b)), веб апликации (shiny (Chang et al. 2020)), блогови (blogdown (Xie 2020a)), итн. Самиот овој текст го пишувамe со помош на bookdown, што овозможува неверојатно лесно составање и објавивање на подолги текстови (книги) со поглавја, компјутерски код, и математичка нотација со едно копче во Rstudio. Заедницата на корисници на R е веројатно една од најактивните кога станува збор за повторливи анализи. На пример, организацијата rOpenSci комплетно посветена кон поддршка и развој за алатки (R библиотеки) за транспарентни, повторливи истражувања. За горе-долу комплетна листа на ресурси поврзани со оваа тема, посетете ја CRAN (Comprehensive R Archive Network) страницата посветена на повторлива наука: CRAN Task View: Reproducible Research. Во овој текст немаме намера да навлегуваме длабоко во самото кодирање во R. Нашиот приод ќе биде да објасниме одреден принцип со обични зборови и да покажеме како тоа би можело да изгледа со R код. Што значи, дури и да не знаете ништо за R би можеле да го следите текстот и да ги употребите препораките во вашиот омилен програмски јазик за обработка на податоци. Во некои делови ќе користиме материјали кои се специфични за R и Rstudio (на пример Rmarkdown) така што можеби ќе има технички детали кои нема да може да директно да ги примените во Jypiter тетратка или доколку работите во друг текст едитор (VScode). Но повторно, имајќи предвид дека препораките ќе тежнеат кон тоа како да пишуваме код којшто ќе бара минимална интервенција при (ре)анализа на податоци, ваквите аспекти специфични за Rstudio ќе бидат сведени на минимум. Генерално, целта ни е да креираме пакет (фолдер) за правење пита што вклучува се што е неопходно за нашиот пријател да може без многу мислење да ја направи истата пита. За да го олесниме овој процес, треба да се стремиме кон тоа да не користиме специјален тарун (софтвер) за да ги сукаме корите, бидејќи таков тарун можеби нема да биде лесно достапен за нашиот пријател. Со други зборови, повторувањето на нашите резултати генерално не треба да зависи од едиторот за текст којшто ние го користиме. 2.2 Контрола на изворен код: git Контрола на изворниот код, најчесто со git (поглавје 7), е платформата што ни дава безбедност и слобода во секоја активност поврзана со програмски код, вклучително и при анализирање и ревизирање анализи на податоци. Во основа, git e систем за undo/redo на стероиди, што може да следи две или повеќе верзии на изворниот код (гранки), од два или повеќе компјутери, овозможува соработници од различни локации истовремено да праваt поправки и унапредувања без да си ги пребришуваат промените, и дозволува да се вратите на верзијата од пред два месеци без да ги изгубите меѓувремени промени. Во денешно време е невозможно да се замисли организација која зависи од програмски код за дел од своите фунцкии без употреба на git (или друг систем на контрола на изворен код). Стриктно гледано, git не е неопходен за правење повторливи анализи. Можно е да напишеме и споделиме скрипта која обработува некои податоците без да ги следиме промените на тој код. Но имајќи во предвид дека при обработка на податоци постојано се соочуваме со одлуки и ревизии, веројатно е ќе се најдеме на брег на река каде што ќе сакаме целиот товар да го спакуваме во водоотпорена вреќа пред да ја преминеме реката. git го овозможува токму тоа и скоро сигурно ќе го користите доколку работите на транспарентната анализа на податоци. 2.3 Резиме Корисно е да ги табулираме овие алатки во споредба со компонентите кои ги воведовме претходно во поглавје 1.1): Table 2.1: Компонентите на повторување на анализа со соодветните софтверски алатки. Аналог Компонента Алатка Состојки Податоци csv, MySQL Рецепта Изворен код R скрипта со git контрола Алатки Зависности на кодот dplyr, ggplot2 Кујна Виртуелен контејнер docker (во следното издание) "],["nogood.html", "Chapter 3 Анализи што не може да се повторат 3.1 Типична анализа (која никој, дури ни авторот, не може да ја повтори) 3.2 Типични пракси кои доведуваат до не-повторливи анализи", " Chapter 3 Анализи што не може да се повторат 3.1 Типична анализа (која никој, дури ни авторот, не може да ја повтори) Да погледнеме една хипотетичка но веројатно честа ситуација. Вие работите на некој проект што се однесува на податоци за сточарство во Македонија. Поврзани сте со локална дата база, имате големо парче податоци вчитани во меморија и работна средина со 10 закачени R пакети (библиотеки). Ви стигнува ургентна е-пошта од колега кој бара да се направи сумирање на месечните трошоци на работа групирано по тип на трошок и по вработен. Вие велите, ах, ајде ова на брзина, ги снимате податоците во Downloads и почнувате: trosoci &lt;- read_csv(&quot;~/Downloads/trosoci-moja-firma.csv&quot;) trosoci_sumirani &lt;- trosoci %&gt;% group_by(vraboten, tip_na_trosok) %&gt;% summarise_at(&quot;cena&quot;, &quot;sum&quot;) %&gt;% arrange(vraboten, tip_na_trosok) write_csv(trosoci_sumirani, path = &quot;~/Download/trosoci-moja-firma-sumirani.csv&quot;) За пет минути сте готови со минимална дистракција, па дури и не мрднавте од претходниот проект. Ја праќате новата табела на колегата. Супер. Фала многу. Половина час подоцна стигнува е-пошта од претпоставениот со пофалба за брзо завршената работа и соработката со колегата. Шефицата исто вели ајде прати ни го кодот за да го забрзаме процесот во иднина и да не одземаме време од комплексните анализи кои ви се примарна задача. Вие го копирате кодот од историја на вашето Rstudio и го праќате: trosoci &lt;- read_csv(&quot;~/Downloads/trosoci-moja-firma.csv&quot;) trosoci_sumirani &lt;- trosoci %&gt;% group_by(vraboten, tip_na_trosok) %&gt;% summarise_at(&quot;cena&quot;, &quot;sum&quot;) %&gt;% arrange(vraboten, tip_na_trosok) write_csv(trosoci_sumirani, path = &quot;~/Download/trosoci-moja-firma-sumirani.csv&quot;) Но, како што можеби веќе очекувате, приказната не завршува тука. Стигнува нова пошта со пораката: \"Кај мене ова не работи?!?“ Зошто? Па има неколку можни причини: Првата линија код чита податоци од ~/Downloads/trosoci-moja-firma.csv. Зошто претпоставуваме дека колегите ќе ја имаат таа табела во тој фолдер? Проблем со податоците (состојките) Првата линија код чита податоци од ~/Downloads/trosoci-moja-firma.csv. Зошто претпоставуваме дека колегата ќе работи на Linux а не Windows на пример, па дури и да ги имаат податоците во Downloads патеката до тој фолдер ќе биде различна (на пр. C:\\Downloads) не ~/Downloads)? Проблем со податоците (состојките) и со кодот (рецептот) Во кодот што го пративме, не вчитуваме никакви пакети, иако користиме функции од два нестандардни пакети во R: readr (Wickham, Hester, and Francois 2018) и dplyr (Wickham, François, et al. 2020). Ние не ги вчитавме овие пакети бидејќи беа закачени во проектот на којшто работевме претходно (сетете се дека не отворивме нов проект). Зошто претпоставуваме дека колегите ќе ги имаат овие пакети закачени во нивната работна средина? Проблем со кодот (рецептот) и со зависности (алатки). Иако ова личи за тривијален пример, проблемите не се тривијални. Обидете се да екстраполирате кон сериозна анализа со 500 линии код и ќе видите дека е скоро невозможно да се следи процесот и повтори анализата (направи питате) без далеку поголема грижа околу кодот (рецептот). Горе се главните проблеми кои ја прават нашата кратка анализа не-повторлива. Но има и уште неколку дополнителни забелешки: Патеката ~/Downloads/trosoci-moja-firma.csv е со голема веројатност надвор од работната папка за било кој од вработените. Веројатнио никој не работи во Downloads, туку во папка наменета за различни проекти. Дополнително, многу е често папки како Downloads да се бришат/празнат со цел да не чуваме застарени датотеки коишто повторно можеме да ги преземеме. Значи за една недела, дури ни ние самите можеби нема да можеме да ја повториме анализата бидејќи датотеката ќе биде избришана. На втората команда во нашиот код, ние ја користиме функцијата summarise_at којашто е едноставен начин да дадеме инструкција да се сумираат цените. Но, зависно од верзијата на R и dplyr, функцијата summarise_at можеби нема да биде достапна. Доколку вашиот колега користи многу стара верзија на dplyr, функцијата summarise_at нема да биде дел од тој пакет со таа верзија, додека со најновата верзија на dplyr, ќе добиеме предупредување за summarise_at дека наскоро ќе биде заменета со подобра алтернатива. Се разбира овие детали не се толку битни, но веројатно е очигледна поентата дека треба да укажеме која верзија од некој пакет сме ја користеле за да може да се повтори нашата анализа. Патеката која ја користиме за да ја зачуваме табелата е фиксна, што значи ако сакаме да ја повториме процедурата за некоја друга табела, при зачувување ќе ја пребришеме првата зачувана табела. Значи, во навидно едноставна задача, што може да се заврши со три линии код, ние прекршивме неколку правила за безбедна пракса при анализирање на податоци. Во ова сценарио, дури ни оригиналниот автор на кодот не би можел да гарантира дека ќе може да ја повтори обработката на податоците во иднина. 3.2 Типични пракси кои доведуваат до не-повторливи анализи Корисно е да споменеме некои од главните пракси кои доведуваат до ситуации како примерот погоре. Доколку при анализа на податоци некој аспект од вашата средина наликува на некоја од овие забелешки, тогаш имајте предвид дека вашата анализа може да биде проблематична за повторување. Генерално, обидете се да ги идентификувате и корегирате ваквите проблеми што е можно порано, бидејќи никој од нас не сака да менува код од стотици линии или да заменува библиотека откако сме завршиле пола од работата. Податоците и кодот не се сместени во истиот директориум. На пример податоци во C:/Data, а код во C:/Analizi. Кодот користи апсолутни патеки за вчитување или зачувување на табели (на пример: C:/Data/Мај2020/трошоци/). Ваквите апсолутни патеки со голема сигурност не се портабилни. Код без документација (коментари кои типично почнуваат со #) или README фајл кој ќе укаже како, по кој редослед да се користат скриптите и кои податоци се користат во која скрипта или кој график. Код без повикани зависности (користени библиотеки) и без информација за верзиите на повиканите зависности. Објекти со податоци кои не се експлицитно вчитани со код (укажува на податоци кои се во нашата работна средина но веројатно нема да бидат достапни за други). Работиме на нешто што вклучува случајност (randomness) но немаме наместено зачеток за генераторот на рандом бројки (set.seed во R). Ова се случува секогаш кога делиме податоци на сетови за тренирање и тестирање во машинско учење на пример. Очекуваме дека оваа листа ќе расте како што овој текст напредува понатаму. "],["conversion.html", "Chapter 4 Конверзија во повторлив код 4.1 Податоци 4.2 Први чекори кон повторливост 4.3 Функција 4.4 Rscript што може да го користиме без да отвараме R 4.5 Резиме", " Chapter 4 Конверзија во повторлив код 4.1 Податоци За да може да ги видиме следните чекори во акција неопходни ни се податоци. Табелата за трошоци има три колони (варијабли) vraboten, tip_na_trosok и cena. Еве ги првите неколку редови: trosoci ## # A tibble: 30 x 3 ## vraboten tip_na_trosok cena ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Ана И. печатење 75 ## 2 Ристе Н. транспорт 81 ## 3 Ана И. печатење 13 ## 4 Благоја В. канцелариски материјали 40 ## 5 Антонија А. транспорт 89 ## 6 Љупчо В. печатење 48 ## 7 Благоја В. канцелариски материјали 96 ## 8 Љупчо В. канцелариски материјали 23 ## 9 Љупчо В. транспорт 84 ## 10 Ана И. печатење 29 ## # … with 20 more rows Трансформацијата која ја прави нашиот, сѐ уште неповторлив, код можеме исто така да ја видиме во акција: trosoci %&gt;% group_by(vraboten, tip_na_trosok) %&gt;% summarise_at(&quot;cena&quot;, &quot;sum&quot;) %&gt;% arrange(vraboten, tip_na_trosok) ## # A tibble: 12 x 3 ## # Groups: vraboten [5] ## vraboten tip_na_trosok cena ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Ана И. канцелариски материјали 31 ## 2 Ана И. печатење 177 ## 3 Ана И. транспорт 51 ## 4 Антонија А. печатење 324 ## 5 Антонија А. транспорт 111 ## 6 Благоја В. канцелариски материјали 196 ## 7 Благоја В. печатење 218 ## 8 Благоја В. транспорт 54 ## 9 Љупчо В. канцелариски материјали 23 ## 10 Љупчо В. печатење 48 ## 11 Љупчо В. транспорт 127 ## 12 Ристе Н. транспорт 116 4.2 Први чекори кон повторливост Откако сме ги согледале проблемите што доведуваат до тоа резултатот од нашиот код да не може да се повтори (без колегата да почне да чепка и кодира од почеток), можеме да интервенираме. За нашиот код да биде повторлив, минимално треба: Да ги повикува R пакетите кои се неопходни за функциите што ги користиме Да не користи апсолутни патеки за вчитување и зачувување на патоци коишто се надвор од фолдерот во кој што е сместена самата скрипта Да биде детално документиран Што се однесува до првиот проблем, кодот едноставно нема да работи без тие пакети да се вчитани па дури и нашиот колега да ги има истите фајлови на истите локации како ние. Оваа корекција е едноставна: # Вчитај ги ти пакетите кои се користат подолу library(dplyr) library(readr) # Доколку не се достапни, инсталирај со: # install.packages(&quot;dplyr&quot;) # install.packages(&quot;readr&quot;) trosoci &lt;- read_csv(&quot;data/trosoci-moja-firma.csv&quot;) trosoci_sumirani &lt;- trosoci %&gt;% group_by(vraboten, tip_na_trosok) %&gt;% summarise_at(&quot;cena&quot;, &quot;sum&quot;)%&gt;% arrange(vraboten, tip_na_trosok) write_csv(trosoci_sumirani, path = &quot;data/trosoci-moja-firma-sumirani.csv&quot;) Што се однесува до втората задача, имаме повеќе можности. Можеме да побараме корисникот да ја зачува патеката во варијабла која ќе биде користена од понатамошниот код. Ова се уште дозволува патеки во друг директориум, и очигледно бара соодветна интервенција од корисникот, но ако ништо друго, корисникот на овој код, доколку ја прочита документацијата, може барем да ја повтори анализата без да добие грешки: # Вчитај ги ти пакетите кои се користат подолу library(dplyr) library(readr) # Доколку не се достапни, инсталирај со: # install.packages(&quot;dplyr&quot;) # install.packages(&quot;readr&quot;) # ВНИМАНИЕ: # Скриптата нема да работи доколку не внесете валидни дестинации # за фајлови за вчитување и зачувување pateka_do_input &lt;- NULL # &quot;data/trosoci-moja-firma.csv&quot; pateka_za_output &lt;- NULL # &quot;data/trosoci-moja-firma-sumirani.csv&quot; # На пример: # pateka_do_input &lt;- &quot;~/Downloads/trosoci-moja-firma.csv&quot; # pateka_do_output &lt;- &quot;~/Downloads/trosoci-moja-firma-sumirani.csv&quot; # или: # pateka_do_input &lt;- &quot;C:\\rabota\\podatoci\\trosoci\\trosoci-moja-firma.csv&quot; # pateka_do_output &lt;- &quot;C:\\rabota\\podatoci\\trosoci\\trosoci-moja-firma-sumirani.csv&quot; # Вчитај ги податоците trosoci &lt;- read_csv(pateka_do_input) # Групирај и пресметај суми trosoci_sumirani &lt;- trosoci %&gt;% group_by(vraboten, tip_na_trosok) %&gt;% summarise_at(&quot;cena&quot;, &quot;sum&quot;) %&gt;% arrange(vraboten, tip_na_trosok) # Зачувај write_csv(trosoci_sumirani, path = pateka_za_output) 4.3 Функција Алтернатива која бара малку поголема подготовка е да го напишеме функција којашто ќе работи на ист начин, земајќи ги патеките како аргументи: sumiraj_trosoci &lt;- function(trosoci, destinacija) { # Вчитај ги податоците trosoci &lt;- read_csv(trosoci) # Групирај и пресметај суми trosoci_sumirani &lt;- trosoci %&gt;% group_by(vraboten, tip_na_trosok) %&gt;% summarise_at(&quot;cena&quot;, &quot;sum&quot;) %&gt;% arrange(vraboten, tip_na_trosok) # Зачувај write_csv(trosoci_sumirani, path = destinacija) } Често, сакаме табелата којашто ја снимаме да го има истото основно име како табелата што ја трансформираме (на пример moja-tabela.csv и moja-tabela-medijani.csv) и да се наоѓа во истиот фолдер. Со малку манипулација на текст во R (ова е уште полесно во Python) добиваме: # Функција за групирање и сумирање трошоци # Аргументот `trosoci` е патека до табелата што треба да се трансформира sumiraj_trosoci &lt;- function(trosoci_tabela) { # Вчитај ги податоците trosoci &lt;- read_csv(trosoci_tabela) # Групирај и пресметај суми trosoci_sumirani &lt;- trosoci %&gt;% group_by(vraboten, tip_na_trosok) %&gt;% summarise_at(&quot;cena&quot;, &quot;sum&quot;) %&gt;% arrange(vraboten, tip_na_trosok) # Направи патека за дестинација folder_name &lt;- dirname(trosoci_tabela) base_name &lt;- tools::file_path_sans_ext(basename(trosoci_tabela)) new_name &lt;- paste(base_name, &quot;sumirani.csv&quot;, sep=&quot;-&quot;) destinacija &lt;- file.path(folder_name, new_name) # Зачувај write_csv(trosoci_sumirani, path = destinacija) } Целата скрипта по овие промени би изгледала вака: # Употреба: # Вчитај ја оваа скипта во R за да ја користиш функцијата `sumiraj_trosoci` # Вчитај ги ти пакетите кои се користат подолу library(dplyr) library(readr) # Доколку не се достапни, инсталирај со: # install.packages(&quot;dplyr&quot;) # install.packages(&quot;readr&quot;) # Функција за групирање и сумирање трошоци # Аргументот `trosoci` е патека до табелата што треба да се трансформира sumiraj_trosoci &lt;- function(trosoci_tabela) { # Вчитај ги податоците trosoci &lt;- read_csv(trosoci_tabela) # Групирај и пресметај суми trosoci_sumirani &lt;- trosoci %&gt;% group_by(vraboten, tip_na_trosok) %&gt;% summarise_at(&quot;cena&quot;, &quot;sum&quot;) %&gt;% arrange(vraboten, tip_na_trosok) # Направи патека за дестинација folder_name &lt;- dirname(trosoci_tabela) base_name &lt;- tools::file_path_sans_ext(basename(trosoci_tabela)) new_name &lt;- paste(base_name, &quot;sumirani.csv&quot;, sep=&quot;-&quot;) destinacija &lt;- file.path(folder_name, new_name) # Зачувај write_csv(trosoci_sumirani, path = destinacija) } Што сме постигнале до сега? Зависностите на кодот се решени. Документација имаме, впрочем, пишување на коментари во кодот треба да стане навика. И имаме функција на која може да и дадеме табела која што се наоѓа било каде и да зачуваме сумирана табела во истиот фолдер. 4.4 Rscript што може да го користиме без да отвараме R TODO: (for windows see: https://stackoverflow.com/questions/3506007/running-r-code-from-command-line-windows) Нашиот код е далеку подобар и има повеќе шанси да работи на други компјутери, но се уште може да се каже дека има некои недостатоци. На пример, корисникот мора да отвори R, да ја вчита скриптата, и да ја изврши функцијата. Тоа е можеби во ред доколку нашиот колега има доволно познавање од R, но можеби нашиот шеф не знае R или едноставно нема време за чепкање во R терминал. Можеби сака решение од една линија: Rscript sumiraj_trosoci.R trosoci_dekemvri_2020.csv Да го конвертираме нашиот код во ваква скрипта е лесно. Доколку кодот го процесираме со Rscript, треба само да го земеме името на фајлот даден по името на скриптата (тоа е табелата со трошоци), и да го предадеме на нашата функција (внатре во скриптата): # (data/sumiraj-trosoci-1.R) # Употреба: # Вчитај ја оваа скипта во R за да ја користиш функцијата `sumiraj_trosoci` # Закачи ги ти пакетите кои се користат подолу library(dplyr) library(readr) # Доколку не се достапни, инсталирај со: # install.packages(&quot;dplyr&quot;) # install.packages(&quot;readr&quot;) # Функција за групирање и сумирање трошоци # Аргументот `trosoci` е патека до табелата што треба да се трансформира sumiraj_trosoci &lt;- function(trosoci_tabela) { # Вчитај ги податоците trosoci &lt;- read_csv(trosoci_tabela) # Групирај и пресметај суми trosoci_sumirani &lt;- trosoci %&gt;% group_by(vraboten, tip_na_trosok) %&gt;% summarise_at(&quot;cena&quot;, &quot;sum&quot;) %&gt;% arrange(vraboten, tip_na_trosok) # Направи патека за дестинација folder_name &lt;- dirname(trosoci_tabela) base_name &lt;- tools::file_path_sans_ext(basename(trosoci_tabela)) new_name &lt;- paste(base_name, &quot;sumirani.csv&quot;, sep=&quot;-&quot;) destinacija &lt;- file.path(folder_name, new_name) # Зачувај write_csv(trosoci_sumirani, path = destinacija) } # Земи го првиот аргумент dadeni_trosoci &lt;- commandArgs(trailingOnly=TRUE)[[1]] # Изврши ја функцијата sumiraj_trosoci(trosoci = dadeni_trosoci) Доколку го тестирате кодот додека читате го имате преземено директориумот за овој текст, оваа скрипта и податоците за трошоци се наоѓаат како фолдерот data под името sumiraj-trosoci-1.R и trosoci-moja-firma.csv. Доколку сакаме навистина да се потрудиме, како поради безбедност така и поради лесно користење на ваквата скрипта, можеме да додадеме кратко упатство за користење, и код за проверка на аргументот. За да направиме упатство за користење, ќе го користиме пакетот docopt кој што користи таканаречен docstring, односно текст којшто следи некои правила за форматирање со цел да биде лесно парсиран како прирачник за употреба на нашата скрипта. docopt/docstring имаат еквиваленти во сите други програмски јазици, така да доколку програмирате во Python или Perl веројатно ви се веќе познати овие концепти. За да провериме дека се е во ред со табелата што и е дадена на скриптата, ќе го користиме пакетот assertthat, што ни овозможува лесни проверки и информативни пораки за грешката. Стриктно гледано, пакетите docopt и assertthat не се неопходни, можеме да користиме функции како commandArgs() и stopifnot() од основната дистрибуција на R. Но во некои случаи користење на додатни пакети навистина ја олеснува работата. # (data/sumiraj-trosoci-2.R) &#39;Сумирај трошоци групирани по вработен и тип на трошок. Табелаta со трошоци мора да ги содржи колоните: `vraboten`, `tip_na_trosok`, и `cena`. Usage: sumiraj-trosoci-2.R &lt;tabela_so_trosoci&gt; sumiraj-trosoci-2.R --help sumiraj-trosoci-2.R --version Options: --help Прикажи помош --version Прикажи верзија &#39; -&gt; doc # Логика за аргументи library(docopt) arguments &lt;- docopt(doc, version = &quot;Сумирај трошоци 2.0\\n&quot;) # Провери дали табелата е csv формат assertthat::assert_that( assertthat::has_extension(arguments$tabela_so_trosoci, ext = &quot;csv&quot;)) # Вчитај ги ти пакетите кои се користат подолу suppressPackageStartupMessages({ library(dplyr) library(readr) library(assertthat) }) # Доколку не се достапни, инсталирај со: # install.packages(&quot;dplyr&quot;) # install.packages(&quot;readr&quot;) # install.packages(assertthat) # Функција за групирање и сумирање трошоци # Аргументот `trosoci_tabela` е патека до табелата што треба да се трансформира sumiraj_trosoci &lt;- function(trosoci_tabela) { # Вчитај ги податоците trosoci &lt;- read_csv(trosoci_tabela) assertthat::assert_that(inherits(trosoci, &quot;data.frame&quot;), msg = &quot;Табелата не беше вчитана како `data.frame`.&quot;) assertthat::assert_that(all(c(&quot;vraboten&quot;, &quot;tip_na_trosok&quot;, &quot;cena&quot;) %in% names(trosoci)), msg = &quot;Табелата мора да содржи колони со имињата: &#39;vraboten&#39;, &#39;tip_na_trosok&#39;, &#39;cena&#39;.&quot;) assertthat::assert_that(is.numeric(trosoci$cena), msg = &quot;Колоната `cena` мора да биде нумеричка.&quot;) # Групирај и пресметај суми trosoci_sumirani &lt;- trosoci %&gt;% group_by(vraboten, tip_na_trosok) %&gt;% summarise_at(&quot;cena&quot;, &quot;sum&quot;) %&gt;% arrange(vraboten, tip_na_trosok) # Направи патека за дестинација folder_name &lt;- dirname(trosoci_tabela) base_name &lt;- tools::file_path_sans_ext(basename(trosoci_tabela)) new_name &lt;- paste(base_name, &quot;sumirani.csv&quot;, sep=&quot;-&quot;) destinacija &lt;- file.path(folder_name, new_name) # Зачувај write_csv(trosoci_sumirani, path = destinacija) } # Земи го првиот аргумент (табелата) dadeni_trosoci &lt;- arguments$tabela_so_trosoci # Изврши ја функцијата sumiraj_trosoci(trosoci = dadeni_trosoci) Со овие додатоци, нашата скрипта сега ќе може дури и да им помогне на корисниците доколку наидат на грешка. Сѐ уште не сме комплетно безбедни од не-повторливост, но стигнавме далеку имајќи во предвид каде почнавме. На пример, ако ја извршиме скриптата без аргументи: $ Rscript sumiraj-trosoci-2.R Error: Сумирај трошоци групирани по вработен и тип на трошок. Табелаta со трошоци мора да ги содржи колоните: `vraboten`, `tip_na_trosok`, и `cena`. Usage: sumiraj-trosoci-2.R &lt;tabela_so_trosoci&gt; Execution halted Со коректен инпут: $ Rscript sumiraj-trosoci-2.R trosoci-moja-firma.csv [1] TRUE Parsed with column specification: cols( vraboten = col_character(), tip_na_trosok = col_character(), cena = col_double() ) Со погрешен фајл, праќаме ексел наместо текстуална табела со запирки: Rscript sumiraj-trosoci-2.R trosoci-moja-firma.xls Error: File &#39;trosoci-moja-firma.xls&#39; does not have extension csv Execution halted Ако колоната за cena е крстена eur: Rscript sumiraj-trosoci-2.R trosoci-moja-firma-eur.csv [1] TRUE Parsed with column specification: cols( vraboten = col_character(), tip_na_trosok = col_character(), eur = col_double() ) Error: Табелата мора да содржи колони со имињата: &#39;vraboten&#39;, &#39;tip_na_trosok&#39;, &#39;cena&#39;. Execution halted 4.5 Резиме Во ова поглавје видовме како нашите едноставни три линии код напишани набрзина можеме да ги претвориме во постабилна скрипта која веќе ги има следните карактеристики значајни за повторливост: Сите зависности на кодот се експлицитно наведени и пакетите се вчитани Скриптата не зависи од нашата работна средина Имаме далеку подобра документација, како за корисници кои ќе го отворат фајлот, така и за тие кои само ќе ја вчитаат скриптата Имаме неколку проверки/валидации на табелата што се трансформира – мора да осигураме дека табелата ги исполнува потребите пред да почнеме да сумираме Имаме автоматско составување на името за зачувување од коренот на името на табелата што ја праќаме во скриптата Сите овие чекори придонесуваат до побезбедно и одбранбено (дефенсивно) програмирање, односно пракса која ги зголемува шансите дека некој код ќе работи како што се очекува надвор од контекстот во кој бил креиран. Во овој случај, контекстот на креирање беше нашата R сесија со 10 вчитани пакети и датотека зачувана во ~/Downloads на Linux оперативен систем. Видовме дека и само еден од овие аспекти на работната средина да варира кај нашите колеги, нашата скрипта нема да работи без тие да почнат да го менуваат изворниот код. Но со наведените подобрувања ги предвидуваме и надминуваме голем дел од овие проблеми. Независно, иако направиме голем напредок кон повторлива обработка на податоци, сѐ уште правиме некакви претпоставки за контекстот во кој скриптата ќе биде користена. На пример, претпоставуваме дека сите потенцијални корисници ќе имаат табелата со трошoци, дека сите корисници ќе имаат R и Rscript инсталирано за да можат да ја извршат скриптата, и дека сите корисници ќе ги имаат инсталирано библиотеките од кои зависи нашата скрипта. Во следните поглавја ќе разгледаме начини на кои може да составиме повторливи проекти кои вклучуваат многу скрипти и податоци и прават минимални претпоставки за средината во која некој ќе се обиде да ја повтори нашата анализа. "],["rmd.html", "Chapter 5 Повторливи документи / извештаи со писмено програмирање (R + markdown) 5.1 Форматирање на текст со markdown 5.2 Плетење на текст, код, и резултати со knitr 5.3 Извештаи со параметри 5.4 Следни чекори", " Chapter 5 Повторливи документи / извештаи со писмено програмирање (R + markdown) Во претходното поглавје, се запознавме со некои од главните методи за обезбедување на нашиот програмски код со цел да биде фунцкионален и на нечиј друг компјутер. Разгледавме ситуација со една скрипта и една табела со резултати, но доколку се запрашаме, сигурно ќе се согласиме дека речиси никогаш не е доволно да се испрати (или објави) само една табела или пресметка. Наспроти, често потребно е да се додаде текстуално објаснување или некаков друг контекст на податоците. Исто така, во многу случаи, нашите визуелизации во форма на табели или графици, или нашите статистички резултати (t-вредности, p-вредности, равенки за регресија), треба да ги прикажеме заедно со програмскиот код кој сме го напишале за да дојдеме то тие резултати. За едноставно комбинирање на код, податоци, резултати и текст во еден документ, светот на R се користи Rmarkdown. Rmarkdown овозможува комбинирање на сите елементи на едно истражување во документ погоден за понатамошно споделување. Патем, така е напишан и овој прирачник, кој исто така цели да биде повторлив. 5.1 Форматирање на текст со markdown Markdown, за разлика од markup програмски јазици како HTML или LaTeX има за цел да го поедностави процесот на форматирање на текст. За детална референца на филозофијата и синтаксата на markdown, погледнете ги официјалните вебсајти нa оригиналната спецификација или поновата стандардизирана спецификација. Во контекст на R и Rstudio погледнете го поглавјето за Rmarkdown во книгата R for Data Science или овој блогпост (и линковите таму) посветен на процесот на развивање на R код, или развивање на една анализа низ призмата на писмено програмирање со Rmarkdown („писмено“ го преведуваме од англиското ‘literal programming’). Тука, накратко ќе ги споменеме најчестите компоненти. На пример, обичниот текст со мала декорација прикажан тука: Оваа _реченица_ е напишана во **markdown** но не е процесирана за да се покаже синтаксата. На [овој линк](https://kbroman.org/knitr_knutshell/pages/Rmarkdown.html) или [овој линк](https://rmarkdown.rstudio.com/authoring_quick_tour.html) можете да прочитате повеќе за пишување `Rmarkdown`. За директни калкулации во текстот, користите ja следната синтакса: `р 3.14 * 2`. Kаде што првиот елемент на парчето (chunk) укажува како да го процесираме кодот што следи. **За `R` користете `r`**. (Во ова не-процесирано парче, не користиме кирилично `р` токму со цел на тоа да ја покажеме синтакста без да го конвертираме кодот во пресметаната вредност) За прикажување математичка нотација, користете: $P = r^2 * \\pi$ по процесирањето ќе биде конвертиран во следниот параграф: Оваа реченица е напишана во markdown но не е процесирана за да се покаже синтаксата. На овој линк или овој линк можете да прочитате повеќе за пишување Rmarkdown. За директни калкулации во текстот, користите ja следната синтакса: 6.28. Kаде што првиот елемент на парчето (chunk) укажува како да го процесираме кодот што следи. За R користете r. (Во ова не-процесирано парче, ние користиме кирилично р токму со цел на тоа да ја покажеме синтакста без да го конвертираме кодот во пресметаната вредност.) За прикажување математичка нотација, користете: \\(P = r^2 * \\pi\\) Забележуваме дека е навистина еднотавно да се куца обичен текст кој во HTML, PDF, или Word документ ќе биде прикажан како задебелен, курзив, со линкови, итн. 5.2 Плетење на текст, код, и резултати со knitr Досега видовме како можеме лесно да маркираме обичен текст кој ќе биде процесиран во убаво форматиран документ. Она што ни недостасува е комбинирање (плетење) на ваквиот текстот со програмски код и резултатите од тој код. Rmarkdown го прави овој чекор супер едноставен. Се што е неопходно е да додадеме парче код кое почнува со нотацијата ```{r} и завршува со нотацијата ```. Тогаш R и пакетот knitr ќе се обидат да го интерпретираат и извршат сиот текст во ова парче како R код или коментари што почнуваат со #. Доколку извршувањето на тој код резултира со табела или график, knitr ќе го прикаже тој елемент веднаш под извршениот код. Ова е далеку полесно со пример: Пример за еден едноставен Rmd документ што прикажува текст, код, и резултати Откако ќе го сплетеме овој документ, добиваме: HTML документ креиран со плетењето на горниот Rmd код Ова навистина само ја допира површината на тоа што е можно да се направи со алатките како rmarkdown и knitr. Имајќи во предвид дека крајните документи се HTML, LaTex, или MS Word, голем дел од богатсвото на можности на овие далеку поопширни markup системи ќе ви бидат достапни кога пишувате анализи во Rmd. Така да, ако сакате да вклучите лого од вашата организација, посебен фонт, специјално форматирње на маргини, пагинација, итн, сето тоа ќе можете тоа да го направите со стандардни методи достапни во HTML или LaTeX. 5.3 Извештаи со параметри Она што за нас е посебно корисно и интересно, е користењето на оваа платформа за писмено програмирање за пишување на параметризирани извештаи. Што значи ова? Па доколку имате некоj стандарден сет на анализи кои треба да ги повторите за сите градови во Македонија, можете да го извршите вашиот Rmd извештај со параметар за тоа кој град треба да биде обработен. Во самиот изворен код на извештајот, дефинирате yaml преамбула налик на следната --- title: Мој Извештај output: html_document params: grad: Tetovo --- Ова креира листа на параметри со името params која е достапна во R средината за време на извршувањето на документот, чијшто елементи може да ги употребите на следниот начин: params$grad Доколку имаме некоја функција во нашиот извештај која се извршува пред правење на некој график за одреден град: library(dplyr) filtriraj_gradovi &lt;- function(podatoci, potreben_grad) { podatoci %&gt;% dplyr::filter(grad == potreben_grad) } Тогаш можете параметарот даден во преамбулата да го искористите при повикувањето на фунцкијата, и сите натамошни резултати ќе бидат посветени на градот што сме го пратиле како параметар: # претходен код и текст filtriraj_gradovi(podatoci = moi_podatoci, potreben_grad = params$grad) # натамошен код и текст За да ги направиме сите извештаи поврзо, во можеме да го повикуваме извршувањето во R конзола: rmarkdown::render(input = &quot;mojizvestaj.Rmd&quot;, params = list(&quot;Tetovo&quot;)) Оттука, во R можеме дури и да напишеме for циклус со кој што ќе ги процесираме сите градови наеднаш и ќе генерираме посебен HTML, PDF или MS Word документ се секој град: gradovi &lt;- c(&quot;Tetovo&quot;, &quot;Gostivar&quot;, &quot;Debar&quot;, &quot;Berovo&quot;, &quot;Dojran&quot;) # ... for ( i in gradovi) { message(&quot;Подготвувам извештај за: &quot;, i) rmarkdown::render(input = &quot;pateka/do/mojizvestaj.Rmd&quot;, params = list(i)) } Како оваа стратегија ја подобрува повторливоста на нашите анализи? Доколку немаме извештаи со параметри можеме да замислиме две стратегии. Првата, имаме еден главен izvestaj.Rmd којшто никогаш не го менуваме и правиме копии за секој град, така што набрзо нашата работна средина станува невозможна за менаџирање на долг рок: izvestaj.Rmd tetovo-izvestaj.Rmd debar-izvestaj.Rmd skopje-izvestaj.Rmd skopje-izvestaj-juni.Rmd skopje-izvestaj-juni-specijalen-so-logo.Rmd kichevo-izvestaj-avgust-2019.Rmd kicevo-izvestaj-avgust.Rmd Втората, имаме еден izvestaj.Rmd којшто го менуваме директно и секогаш мора да го отвориме, промениме, и извршиме рачно. Така да кога ќе стигнат новите податоци следниот месец имаме 2-3 часа работа да го промениме градот во функцијата горе триесетина пати. Дури и да го имате потребното време за вакви активности, очигледно е дека со овие опции е далеку полесно да направите грешка отколку со извештајот со параметри, којшто го пишувате еднаш и можете да го користите секогаш кога ќе ви треба без да го менувате изворниот код. Доколку треба да се измени или подобри извештајот, тоа се прави со промена на само еден документ, не треба да се сетите дека kopje-izvestaj-juni-specijalen-so-logo.Rmd треба да се промени засебно бидејќи има нешто специфично. 5.4 Следни чекори Околината на rmarkdown и knitr е особено богата со алатки за посебни намени што навистина можат да придонесат кон поголема транспарентност, повторливост на вашите анализи и генерално кон поголема продуктивност во вашата работа. Подолу наведуваме само неколку од овие алатки: креирање презентации (на пример: тука, тука, тука) креирање интерактивни Rmd документи што користат Shiny server позадина (линк) креирање стилизирани HTML документи со prettyprint (линк) креирање на книги со bookdown (како овој текст) креирање на едноставни Rmarkdown вебсајти со rmarkdown::render_site (https://rmarkdown.rstudio.com/lesson-13.html) креирање на дашбоарди со flexdashboard "],["proekti.html", "Chapter 6 Повторливи проекти 6.1 Стратегија 1: Направи сам 6.2 Стратегија 2: Формален R пакет или некоја поедноставена варијанта 6.3 Резиме", " Chapter 6 Повторливи проекти Во претходните две поглавја разгледавме како можеме нашиот едноставен код да го конвертираме во скрипта која ќе биде лесна за користење и до некоја мера издржлива во различни работни средини (Поглавје 4) и како да составиме повторлив извештај со повеќе табели и графици со помош на Rmd (Поглавје 5). Но како што напоменавме, сеуште правиме некои претпоставки за начинот на кој ќе биде користена скриптата и за ресурсите кои ќе им бидат достапни на корисниците. Една од овие претпоставки беше дека колегите кои ќе ја користат нашата скрипта ќе имаат адекватни табели за обработување. Ова е до некоја мера разумна претпоставка доколку скриптата се користи рамките на една организација, или доколку типот на табели кои ги обработува се доволно познати и распространети. Но ваквите случаи, иако значајни, претставуваат само дел инстанците кога треба да разговараме за повторливи анализи. Како што споменавме претходно во Секција 1.2 голем дел од сферата на статистички анализи, наука за податоци, и истражувања од било кое поле на науката се однесува на споделување на програмскиот код заедно со податоците, извештаите, презентациите, итн. Значи ни треба начин да го споделиме нашиот програмски код заедно со податоците кои ги обработуваме, инаку никој надвор од нашата организација нема да може да ја повтори анализата. Во ова поглавје ќе се запознаеме со две стратегии за организирање на повторливи проекти. Првата стратегија (Направи сам) е едноставна за поставување и не зависи од дополнителна инфраструктура (додатни библиотеки), но ако проектот е комплексен, оваа опција може да бара повеќе грижа, особено за стабилност на подолг рок. Втората стратегија е да се повикаме на некоја веќе готова платформа за поставување на безбедна структура за повторливи проекти. Втората стратегија генерално треба да се преферира, но имајќи во предвид дека секој нов пакет си бара одреден период на запознавање и дека во некои случаи првата опција е сосема адекватна, ќе збориваме за двете стратегии. 6.1 Стратегија 1: Направи сам 6.1.1 Структура Креирање безбедна структура за повторливост во основа е едноставно. Да речеме дека имаме извештај со два графикони и три табели, и дека секој график и табела се базирани на различни сетови на податоци. Имајќи ги во предвид нашите цели: да направиме што е можно помалку претпоставки за средината во којашто ќе биде повторена нашата анализа и да направиме што е можно полесно да се снајде некој без никакво претходно искуство со нашиот проект можеме секој елемент од нашиот извештај да го енкапсулираме во посебен фолдер. Во секој фолдер мора да ги вклучиме податоците и програмскиот код коишто се неопходни за ре-креирање на графиконот или табелата. За детални објаснувања, можеме во (фали нешто тука?) да вклучиме README фалј во оние фолдери каде што е неопходно. Главен README фалј на првото ниво на нашиот проект мора да биде вклучен. Тука, го опишуваме нашиот проект, што подетално тоа подобро, и даваме објаснување за како да се користат податоците и кодот којшто е вклучен во субфолдерите. Ова е особено важно доколку скриптите зависат една од друга и треба да се извршат во некој редослед, на пример ако мора прво да го извршиме кодот во tabela_1 пред да можеме да работиме со tabela_2. Во нашиот случај, со два графикони и три табели сите со различни податоци, би ја имаме следната структура: strategija_1/ ├── grafik_1 │   ├── code_grafik_1.R │   └── data_grafik_1.csv ├── grafik_2 │   ├── code_grafik_2.R │   └── data_grafik_2.csv ├── README ├── tabela_1 │   ├── code_tabela_1.R │   └── data_tabela_1.csv ├── tabela_2 │   ├── code_tabela_2.R │   └── data_tabela_2.csv └── tabela_3 ├── code_tabela_3.R └── data_tabela_3.csv Доколку графиконите 1 и 2 се базирани на исти податоци како табелите 1 и 2, тогаш можеме да ги групираме, со што би избегнало непотребно копирање на истите податоци на две места: strategija_1/ ├── grafik_1 │   ├── code_grafik_1.R │   ├── code_tabela_1.R │   └── data_grafik_1.csv ├── grafik_2 │   ├── code_grafik_2.R │   ├── code_tabela_2.R │   └── data_grafik_2.csv ├── README └── tabela_3 ├── code_tabela_3.R └── data_tabela_3.csv Но генерално, при одлучување за структурата на проектот треба да си го поставиме прашањето „како најлесно ќе се снајде некој што никогаш претходно нема работено со овие податоци или тип на анализи?“. Доколку одговорот на ова прашање сугерира да се копираат истите податоци на две места, и податоците се доволно мали да го дозволат тоа, тогаш е подобро да се направи вишокот отколку да се направи ре-анализата покомплицирана. 6.1.2 Предности Како оваа стратегија овозможува повторливост? Доколку нашиот код ги следи принципите за кои збориваме претходно, спарувањето на податоците со кодот што треба да се користи за нивна обработка во еден фолдер изолирани од остатокот на проектот значи дека: шансите корисникот на нашиот проект да ги помеша фајловите се минимални, нашиот код може да биде поедноставен бидејќи вчитува податоци во истиот фолдер, и конечно сите резултати од извршувањето на нашиот код (на пример пдф од графикон) ќе се зачуваат во истиот фолдер. Оваа едноставна, линеарна поврзаност е веројатно најбезбедна од аспект на поставување и користење подоцна од некој кој нема никакво претходно познавање. Дополнително, ваквата структура овозможува модуларност, во смисла на тоа дека секоја табела или графикон може да се ре-креира независно од остатокот на анализата, ако, на пример, нашиот соработник или рецензент сака да провери само одреден аспект на истражувањето. 6.1.3 Недостатоци Главните недостатоци на оваа стратегија се непотребното повторување на код или податоци (не секогаш, но често), и тоа што оваа организација станува незгодна ако имаме голем или комплициран извештај со многу анализи коишто би сакале да ги одделиме. Можното непотребно повторување да податоци веќе спомнавме погоре како разлика помеѓу недостатоците на дуплицирање наспроти предноста што копирањето на една табела на две места може да подобри леснотијата на користење. Имено, доколку некоја скрипта има соодветно именувана табела што ја користи во соодветно именуван фолдер, тогаш дури и истата табела да се јави под друго име во друг фолдер каде што се отвара од друга скрипта, тоа не создава забуна. Од друга страна, доколку истата табела, под исто име, се наоѓа во заедничи фолдер Табели, тогаш треба за двете скрипти да објасниме дека ја користат истата табела и двете скрипти треба да повикуваат табела што е сместена надвор од соодветните фолдери. Второто сценарио е малку покомплицирано, и доколку табелата во прашање е доволно мала (во смисол на меморија) тогаш од перспектива на корисник кој прв пат го гледа проектот можеби не е проблем доколку се јавува два пати. Сепак, генералната препорака е дека најдобро е да се избегне дупликација на податоци, бидејќи податоците се (типично) најголемиот (во смисол на меморија) дел од нашиот пакет, а сакаме нашиот пакет да биде што попортабилен. За повторувањето на програмски код имаме слична дилема. Доколку нашите табели или графици, кои ги правиме со посебни скрипти во посебни фолдери, имаат делови со идентичен код (на пример сите скрипти ги прават истите проверки за табелите, или сите скрипти за табела ја прават истата сумација по групи), тогаш можеме делот од кодот што се повторува да го изолираме во посебна скрипта што сите други скрипти ќе ја повикуваат. Оваа опција е подобра бидејќи доколку најдеме грешка или сакаме да направиме некое подобрување, тоа го правиме само во скриптата со заеднички код, додека пак доколку тој код се дуплицира во повеќе скрипти, ќе треба да ги промениме сите. Во ваков случај со изолиран заеднички код, нашата структура може да се промени во нешто налик на следниот дијаграм. strategija_1/ ├── README ├── zaednicki-kod.R ├── grafik_1 │   ├── code_grafik_1.R │   ├── code_tabela_1.R │   └── data_grafik_1.csv ├── grafik_2 │   ├── code_grafik_2.R │   ├── code_tabela_2.R │   └── data_grafik_2.csv └── tabela_3 ├── code_tabela_3.R └── data_tabela_3.csv Вториот недостаток, незгодноста кога проектот станува голем и комплициран, станува јасен со претходниот дијаграм. Кога скриптите, и фунцкии внатре во скриптите, почнуваат да стануваат зависни една од друга, предностите на линерано изолирање на кодот и податоците почнуваат да се смалуваат. На пример, ако code_tabela_3.R има функција sumiraj-po-grupi() која повикува две функции од zaednicki-kod.R и ја вчитува табелата што резултира од модулот grafik_2, тогаш немаме баш линеарна зависност туку нешто покомплицирано. И иако сеуште можеме рачно да ги организираме ваквите врски помеѓу код и податоци, веројатно е време да разгледаме други опции за организирање на нашиот проект. 6.2 Стратегија 2: Формален R пакет или некоја поедноставена варијанта 6.2.1 Структура Разгледувајќи ја првата стратегија за организирање на повторливи проекти дојдовме до моментот кога зависностите помеѓу нашиот код и податоци почнуваа да стануваат не-линеарни. Од една страна, неколку скрипти можат да ги користат истите податоци и да повикуваат функции од една скрипта за заеднички код, од друга страна, една скрипта може да зависи од резултатите на повеќе други прекурсори. Кога нашиот проект ќе ја стигне оваа фаза, тогаш подобро е да ја напуштиме линеарната структура што изолира еден сет на податоците и нивната обработка од остатокот на пакетот и да го реорганизираме проектот така што податоците, кодот, извештате, итн, ќе бидат во засебни фолдери. Во овој случај, структурата на проектот може да биде нешто налик на следниот дијаграм: strategija_2/ ├── izvestai ├── podatoci ├── README └── skripti Доколку некогаш сте ја погледнале структурата на еден формален R пакет (под „формален„ мислиме пакет или библиотека која што може да се инсталира и повика со library(mojpaket)), веднаш ќе ги забележите сличностите: Структура на еден формален R пакет (библиотека) Сиот програмски код е изолиран во посебен фолдер (skripti или R), податоците се во фолдери посветени на податоци (podatoci или data или data-raw), главниот директориум во двата случаи има README фајл кој ја објаснува намената на пакетот и укажува како може да се користат спакувануте компоненти, итн. Како работиме во оваа средина? Без разлика колку скрипти имаме, со колку функции во нив, и колку комплексни се зависностите помеѓу нив: сите тие скрипти ги вчитуваме во нашата R средина (global environment, .GlobalEnv), така што кога една фунција повикува втора функција не мора да се сетиме во која скрипта живее таа функција сите тие скрипти вчитуваат податоци кои се наоѓаат во podatoci и никаде на друго место сите тие скрипти зачувуваат продукти (табели, графици, HTML/PDF извештаи) во izvestai На ваков начин, ја елиминараме потрабата од копирање на податоци или код, и секоја компонента, дали е тоа изворен код или податоци, се јавува само еднаш во нашиот пакет. 6.2.2 Поставување Поставувањето на ваков повторлив проект може повторно да оди рачно, едноставно правиме фолдери за податоци, изборен код, итн. Но исто таке можеме да искористиме постоечки функции и пакети кои го прават овој чекор полесен. Иако има многу решенија достапни решенија, ќе тука ќе споменеме две опции. Прво, можеме да ја искористиме функционалноста за креирање формални R пакети, дури немаме намера да го објавуваме нашиот пакет. Кодот е едноставен: library(devtools) library(usethis) devtoos::create(path = &quot;mojpaket&quot;) podatoci1 &lt;- read.csv(&quot;~/Desktop/moi-podatoci.csv&quot;) usethis::use_data(&quot;podatoci1&quot;) Извршувањето на горните линии ќе креира структура налик на следната: mojpaket/ ├── DESCRIPTION ├── NAMESPACE ├── data └── R Понатаму, како додавате документација, вињети, или тестови, можете да генерирате соодветни фолдери полу-автоматски. За далеку повеќе детали околу овие процедури, ве повикуваме да ја погледнете книгата за R пакети од Хадли Викам ((Wickham 2015)). Втората опција за креирање на ваква структура за повторлив проект е преку користење на пакети посветени кон токму тоа: да олеснат повторливи анализи/истражувања/извештаи преку автоматизирање на некој од компонентите на повторливост кои ги дискутиравме до сега. Има повеќе вакви пакети: prodigenr, makeProject, ProjectTemplate, fertile, goodpractice, итн кои специјализираат кон различни аспекти (дали структура на проектот, проверки на кодот, итн). Овде, накратко, ќе се запознаеме со основната функционалност на пакетот prodigenr кој овозможува креирање на структура налик на формален R пакет но без (понекогаш непотребниот) багаж кој доаѓа со развивањето и користењето на еден формален R пакет. library(prodigenr) setup_project(&quot;data/mojproekt2&quot;) Потоа, доколку го погледнеме направениот проект ја имаме следната структура: mojproekt2/ ├── data │   └── README.md ├── DESCRIPTION ├── doc │   └── README.md ├── mojproekt2.Rproj ├── R │   ├── fetch_data.R │   ├── README.md │   └── setup.R ├── README.md └── TODO.md На пример, скриптата setup.R доаѓа со објаснување како да ги организираме нашите скрипти/функции со цел да бидат достапни за време на интерактивната сесија. Додека пак скриптата fetch_data.R не насочува кон тоа како да ги собираме и подготвиме табелите со податоци за зачувување во data/ и понатамошно користење. Како и во еден формален пакет, фајлот DESCRIPTION дава инструкции за зависностите на нашиот код (не-стандардни R пакети). Како и секогаш, ве покануваме да ја прочитате документацијата на пакетот (на пример library(help=\"prodigenr\")) за повеќе детали. 6.2.3 Предности Очигледно има добри причини зошто би сакале нашиот повторлив проект да има структура слична на формален R пакет. Еден R пакет може да се инсталира и користи без проблем на било кој компјутер, има ефективна документација со вградени упатства за употреба и подолги вињети за специјални случаи, има екплицитно менаџирање на зависностите, и единични тестови (unit tests) кои што проверуваат дали секоја фунцкија го дава очекуваниот резултат во различни контексти. 6.2.4 Недостатоци Може да се најдат недостатоци во било кој систем, и секако оваа структура може сеуште да се подобрува, но за робустна организација на вашите повторливи проекти веројатно треба да се држите до некоја од алтернативите дискутирани тука. Она што може да се спомене, не како недостаток, туку предупредување, е дека навинкувањето и целосно искористување на ова структура ќе бара малку повеќе време и учење, како за оној кој го подготвува проектот така и за корисниците. 6.3 Резиме Без разлика која од овие опции ви ваќа повеќе око, или е поадекватна за вашиот проект, она што навистина прави разлика е внимание, трпение, и дисциплина при поставувањето на структурата на проектот и следењето на најдобрите пракси за повторливо програмирање. Дури и да имате идеална структура за вашиот проект, тоа нема да значи ништо доколку на вториот работен ден почнете да пишувате скрипти без документација или почнете да зачувувате фајлови во главниот фолдер наместо во посветените фолдери. Не се изненадувајте доколку следејќи ги праксите кои ги дискутираме тука текстот кој го пишувате за да документирате како работи одредена скрипта е подолг од самата скрипта што ја објаснувате. "],["git.html", "Chapter 7 Контрола на изворниот код (git / GitHub)", " Chapter 7 Контрола на изворниот код (git / GitHub) Контрола на изворниот код (или дури и на целата содржина во еден истражувачки проект) е можна со помош на користење на алатки како Git. Употребата на Git е олесната благодарение на веб страниците како што се Github или Gitlab. Контролата на содржината е корисна. Кога пишувате текст или код и потоа менувате, Git овозможува да ги видите тие промени, да споредите, или да ги вратите назад. Може да се каже дека тој е многу напредна верзија на вообичаното track changes што се користи во алатки како MS Word. Сепак, детален осврт на можностите и особеносите на Git не е тема овде. За тие што се заинтересирани и сакаат да истражуваат постојат ресурси кои детално ги објаснуваат сите детали. На пр. https://git-scm.com/book/en/v2 Овде ќе се осврнеме само на една можност која што ја нуди Github за презентирање на HMTL документи кои може да произлезат од некои анализи, како на пример со повторливи извештаи во Rmarkdown кои ги конвертираме во HTML (поглавје 6). Git функционира со branches (гранки). Можете да ги замислите гранките слично како посебни директориуми на вашиот компјутер. Главната гранка (main) е местото каде што ги чувате кодот, анализите и податоците. Може да имате многу дополнителни гранки за разни тестови, екпесрименти, верзии, итн. Нешто као кога имате izvestaj-posledna-verzija-final-za-prin-2.doc. :) Една од гранките кои што се достапни на Github има специјално значење и функција. Таа автоматски се објавува на интернет доколку се исполнети неколку услови. Тоа е gh-pages. gh-pages практично овозможува вашиот проект да биде веднаш објавен доколку го имате во HTML фомрат. Ако памтите од поглавјето за Rmarkdown, таквите документи може да се рендерираат во HTML. 7.0.1 Потребен софтвер За да можете да користите git со rstudio потребно е да инсталирате git од https://git-scm.com/download/win. Исто така потребно е да направите ваша сметка на github.com. 7.0.2 Чекори ново репо на гитхуб со реадме. за да се види дека има нешто (и е добра пракса) пулл преку р студио комит и пуш рмд нов бренч од р студио рендер на хтмл-то во новиот бренч локално преименување во индекс.хтмл пуш на индекс хтмл на гх-пагес "],["not-too-much-about-git-of-course-that-is-not-the-point-anyway.html", "Chapter 8 not too much about git (of course that is not the point anyway)", " Chapter 8 not too much about git (of course that is not the point anyway) "],["just-about-creating-a-github-repo-where-you-can-push-rmd-in-main-and-html-in-gh-pages-thus-making-your-reserarch-public-on-the-web-mostly-working-thourgh-r-studio-exept-for-creating-the-account-on-gh-.html", "Chapter 9 just about creating a github repo where you can push rmd in main and html in gh-pages thus making your reserarch public on the web mostly working thourgh r studio exept for creating the account on gh.", " Chapter 9 just about creating a github repo where you can push rmd in main and html in gh-pages thus making your reserarch public on the web mostly working thourgh r studio exept for creating the account on gh. 9.0.1 референци: https://git-scm.com/book/en/v2 "],["references.html", "References", " References Allaire, JJ, Yihui Xie, Jonathan McPherson, Javier Luraschi, Kevin Ushey, Aron Atkins, Hadley Wickham, Joe Cheng, Winston Chang, and Richard Iannone. 2020. Rmarkdown: Dynamic Documents for r. https://github.com/rstudio/rmarkdown. Barrett, Paul, John Hunter, J Todd Miller, J-C Hsu, and Perry Greenfield. 2005. “Matplotlib–a Portable Python Plotting Package.” In Astronomical Data Analysis Software and Systems XIV, 347:91. Chang, Winston, Joe Cheng, JJ Allaire, Yihui Xie, and Jonathan McPherson. 2020. Shiny: Web Application Framework for r. http://shiny.rstudio.com. Dowle, Matt, and Arun Srinivasan. 2019. Data.table: Extension of ‘data.frame‘. https://CRAN.R-project.org/package=data.table. Harris, Charles R, K Jarrod Millman, Stéfan J van der Walt, Ralf Gommers, Pauli Virtanen, David Cournapeau, Eric Wieser, et al. 2020. “Array Programming with NumPy.” Nature 585 (7825): 357–62. McKinney, Wes, and others. 2011. “Pandas: A Foundational Python Library for Data Analysis and Statistics.” Python for High Performance and Scientific Computing 14 (9). Minocher, Riana, Silke Atmaca, Claudia Bavero, Richard McElreath, and Bret Beheim. 2020. “Reproducibility Improves Exponentially over 63 Years of Social Learning Research.” PsyArXiv. https://doi.org/10.31234/osf.io/4nzc7. R Core Team. 2020. R: A Language and Environment for Statistical Computing. Vienna, Austria: R Foundation for Statistical Computing. https://www.R-project.org/. Rossum, Guido. 1995. “Python Reference Manual.” Wickham, Hadley. 2015. R Packages: Organize, Test, Document, and Share Your Code. \" O’Reilly Media, Inc.\". Wickham, Hadley, Winston Chang, Lionel Henry, Thomas Lin Pedersen, Kohske Takahashi, Claus Wilke, Kara Woo, Hiroaki Yutani, and Dewey Dunnington. 2020. Ggplot2: Create Elegant Data Visualisations Using the Grammar of Graphics. https://CRAN.R-project.org/package=ggplot2. Wickham, Hadley, Romain François, Lionel Henry, and Kirill Müller. 2020. Dplyr: A Grammar of Data Manipulation. https://CRAN.R-project.org/package=dplyr. Wickham, Hadley, Jim Hester, and Romain Francois. 2018. Readr: Read Rectangular Text Data. https://CRAN.R-project.org/package=readr. Xie, Yihui. 2020a. Blogdown: Create Blogs and Websites with r Markdown. https://github.com/rstudio/blogdown. ———. 2020b. Bookdown: Authoring Books and Technical Documents with r Markdown. https://github.com/rstudio/bookdown. ———. 2020b. Bookdown: Authoring Books and Technical Documents with r Markdown. https://github.com/rstudio/bookdown. "]]
